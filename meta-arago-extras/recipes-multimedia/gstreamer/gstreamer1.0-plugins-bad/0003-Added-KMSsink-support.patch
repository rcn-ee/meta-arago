From efe7189ee13e78664bbe373c6fd890280c9dee50 Mon Sep 17 00:00:00 2001
From: Pooja Prajod <a0132412@ti.com>
Date: Fri, 12 Dec 2014 13:28:10 +0530
Subject: [PATCH] Added KMSsink support

---
 configure.ac               |   12 +
 sys/Makefile.am            |   10 +-
 sys/kms/Makefile.am        |   29 +
 sys/kms/gstdrmutils.c      |  292 +++++++++
 sys/kms/gstdrmutils.h      |   40 ++
 sys/kms/gstkmsbufferpriv.c |  124 ++++
 sys/kms/gstkmsbufferpriv.h |   64 ++
 sys/kms/gstkmssink.c       |  682 ++++++++++++++++++++++
 sys/kms/gstkmssink.h       |   91 +++
 9 files changed, 1342 insertions(+), 2 deletions(-)
 create mode 100644 sys/kms/Makefile.am
 create mode 100644 sys/kms/gstdrmutils.c
 create mode 100644 sys/kms/gstdrmutils.h
 create mode 100644 sys/kms/gstkmsbufferpriv.c
 create mode 100644 sys/kms/gstkmsbufferpriv.h
 create mode 100644 sys/kms/gstkmssink.c
 create mode 100644 sys/kms/gstkmssink.h

diff --git a/configure.ac b/configure.ac
index b94bd5d..8cdf972 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1400,6 +1400,16 @@ AG_GST_CHECK_FEATURE(KATE, [Kate], kate, [
   AC_SUBST(TIGER_LIBS)
 ],,,[AM_CONDITIONAL(USE_TIGER, false)])
 
+dnl *** kms ***
+translit(dnm, m, l) AM_CONDITIONAL(USE_KMS, true)
+AG_GST_CHECK_FEATURE(KMS, [kmssink], kms, [
+  PKG_CHECK_MODULES([DRM], [libdrm libdrm_omap], HAVE_KMS=yes, HAVE_KMS=no)
+  PKG_CHECK_MODULES(LIBDCE, [libdce >= 1.0.0], HAVE_KMS=yes, HAVE_KMS=no)
+  AC_SUBST(DRM_CFLAGS)
+  AC_SUBST(DRM_LIBS)
+])
+
+
 dnl *** ladspa ***
 translit(dnm, m, l) AM_CONDITIONAL(USE_LADSPA, true)
 AG_GST_CHECK_FEATURE(LADSPA, [ladspa], ladspa, [
@@ -2212,6 +2222,7 @@ AM_CONDITIONAL(USE_GSM, false)
 AM_CONDITIONAL(USE_HLS, false)
 AM_CONDITIONAL(USE_KATE, false)
 AM_CONDITIONAL(USE_TIGER, false)
+AM_CONDITIONAL(USE_KMS, false)
 AM_CONDITIONAL(USE_LADSPA, false)
 AM_CONDITIONAL(USE_LV2, false)
 AM_CONDITIONAL(USE_LIBMMS, false)
@@ -2439,6 +2450,7 @@ sys/osxvideo/Makefile
 sys/qtwrapper/Makefile
 sys/mfc/Makefile
 sys/shm/Makefile
+sys/kms/Makefile
 sys/uvch264/Makefile
 sys/vcd/Makefile
 sys/vdpau/Makefile
diff --git a/sys/Makefile.am b/sys/Makefile.am
index b1abda6..b87a1ca 100644
--- a/sys/Makefile.am
+++ b/sys/Makefile.am
@@ -106,6 +106,12 @@ else
 PVR_DIR=
 endif
 
+if USE_KMS
+KMS_DIR=kms
+else
+KMS_DIR=
+endif
+
 if USE_SHM
 SHM_DIR=shm
 else
@@ -166,9 +172,9 @@ else
 MFC_DIR=
 endif
 
-SUBDIRS = $(ACM_DIR) $(ANDROID_MEDIA_DIR) $(APPLE_MEDIA_DIR) $(AVC_DIR) $(BLUEZ_DIR) $(D3DVIDEOSINK_DIR) $(DECKLINK_DIR) $(DIRECTDRAW_DIR) $(DIRECTSOUND_DIR) $(DIRECTSHOW_DIR) $(DVB_DIR) $(FBDEV_DIR) $(LINSYS_DIR) $(OPENSLES_DIR) $(OSX_VIDEO_DIR) $(PVR_DIR) $(QT_DIR) $(SHM_DIR) $(UVCH264_DIR) $(VCD_DIR) $(VDPAU_DIR) $(WININET_DIR) $(WINSCREENCAP_DIR) $(WASAPI_DIR) $(MFC_DIR)
+SUBDIRS = $(ACM_DIR) $(ANDROID_MEDIA_DIR) $(APPLE_MEDIA_DIR) $(AVC_DIR) $(BLUEZ_DIR) $(D3DVIDEOSINK_DIR) $(DECKLINK_DIR) $(DIRECTDRAW_DIR) $(DIRECTSOUND_DIR) $(DIRECTSHOW_DIR) $(DVB_DIR) $(FBDEV_DIR) $(LINSYS_DIR) $(OPENSLES_DIR) $(OSX_VIDEO_DIR) $(PVR_DIR) $(QT_DIR) $(KMS_DIR) $(SHM_DIR) $(UVCH264_DIR) $(VCD_DIR) $(VDPAU_DIR) $(WININET_DIR) $(WINSCREENCAP_DIR) $(WASAPI_DIR) $(MFC_DIR)
 
 DIST_SUBDIRS = acmenc acmmp3dec androidmedia applemedia applemedia-nonpublic avc bluez d3dvideosink decklink directdraw directsound dvb linsys fbdev dshowdecwrapper dshowsrcwrapper dshowvideosink \
-		opensles osxvideo pvr2d qtwrapper shm uvch264 vcd vdpau wasapi wininet winks winscreencap mfc
+		opensles osxvideo pvr2d qtwrapper kms shm uvch264 vcd vdpau wasapi wininet winks winscreencap mfc
 
 include $(top_srcdir)/common/parallel-subdirs.mak
diff --git a/sys/kms/Makefile.am b/sys/kms/Makefile.am
new file mode 100644
index 0000000..035efef
--- /dev/null
+++ b/sys/kms/Makefile.am
@@ -0,0 +1,29 @@
+plugin_LTLIBRARIES = libgstkmssink.la
+
+libgstkmssink_la_SOURCES = \
+	gstkmssink.c \
+	gstkmsbufferpriv.c \
+	gstdrmutils.c
+
+libgstkmssink_la_CFLAGS = \
+	$(GST_PLUGINS_BAD_CFLAGS) \
+	$(GST_PLUGINS_BASE_CFLAGS) \
+	$(GST_BASE_CFLAGS) \
+	$(LIBDCE_CFLAGS) \
+	$(GST_CFLAGS) \
+	$(DRM_CFLAGS)
+
+libgstkmssink_la_LIBADD = \
+	$(GST_PLUGINS_BASE_LIBS) \
+	$(GST_BASE_LIBS) \
+	$(GST_LIBS) \
+	$(LIBDCE_LIBS) \
+	$(DRM_LIBS) \
+	-lgstvideo-$(GST_API_VERSION) \
+	-lgstdmabuf-$(GST_API_VERSION) \
+	$(top_builddir)/gst-libs/gst/drm/libgstdrm-$(GST_API_VERSION).la
+
+libgstkmssink_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
+libgstkmssink_la_LIBTOOLFLAGS = --tag=disable-static
+
+noinst_HEADERS = gstkmssink.h gstdrmutils.h gstkmsbufferpriv.h
diff --git a/sys/kms/gstdrmutils.c b/sys/kms/gstdrmutils.c
new file mode 100644
index 0000000..d7a8dd6
--- /dev/null
+++ b/sys/kms/gstdrmutils.c
@@ -0,0 +1,292 @@
+/* GStreamer
+ *
+ * Copyright (C) 2012 Texas Instruments
+ * Copyright (C) 2012 Collabora Ltd
+ *
+ * Authors:
+ *  Alessandro Decina <alessandro.decina@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <gst/gst.h>
+#include "gstdrmutils.h"
+
+GST_DEBUG_CATEGORY_EXTERN (gst_debug_kms_sink);
+#define GST_CAT_DEFAULT gst_debug_kms_sink
+
+void
+gst_drm_connector_cleanup (int fd, struct connector *c)
+{
+  if (c->connector) {
+    drmModeFreeConnector (c->connector);
+    c->connector = NULL;
+  }
+  if (c->encoder) {
+    drmModeFreeEncoder (c->encoder);
+    c->encoder = NULL;
+  }
+  if (c->fb_id) {
+    drmModeRmFB (fd, c->fb_id);
+    c->fb_id = 0;
+  }
+  if (c->fb_bo) {
+    omap_bo_del (c->fb_bo);
+    c->fb_bo = NULL;
+  }
+}
+
+static gboolean
+gst_drm_connector_find_mode_and_plane_helper (int fd,
+    struct omap_device *dev, int width, int height,
+    drmModeRes * resources, drmModePlaneRes * plane_resources,
+    struct connector *c, drmModePlane ** out_plane)
+{
+  int i, best_area = 0, ret;
+
+  /* free old stuff: */
+  if (*out_plane) {             /* TODO maybe move into 'struct connector'?? */
+    drmModeFreePlane (*out_plane);
+    *out_plane = NULL;
+  }
+  gst_drm_connector_cleanup (fd, c);
+
+  /* First, find the connector & mode */
+  c->connector = drmModeGetConnector (fd, c->id);
+  if (!c->connector)
+    goto error_no_connector;
+
+  if (!c->connector->count_modes)
+    goto error_no_mode;
+
+  /* just look for the highest resolution: */
+  for (i = 0; i < c->connector->count_modes; i++) {
+    drmModeModeInfo *mode = &c->connector->modes[i];
+    int area = mode->hdisplay * mode->vdisplay;
+
+    if (area > best_area) {
+      c->mode = mode;
+      best_area = area;
+    }
+  }
+
+  if (c->mode == NULL) {
+    /* XXX: just pick the first available mode. Not sure this is correct... */
+    c->mode = &c->connector->modes[0];
+#if 0
+    goto error_no_mode;
+#endif
+  }
+
+  /* Now get the encoder */
+  c->encoder = drmModeGetEncoder (fd, c->connector->encoder_id);
+  if (!c->encoder)
+    goto error_no_encoder;
+
+  if (c->crtc == -1)
+    c->crtc = c->encoder->crtc_id;
+
+  /* and figure out which crtc index it is: */
+  c->pipe = -1;
+  for (i = 0; i < resources->count_crtcs; i++) {
+    if (c->crtc == (int) resources->crtcs[i]) {
+      c->pipe = i;
+      break;
+    }
+  }
+
+  if (c->pipe == -1)
+    goto error_no_crtc;
+
+  *out_plane = NULL;
+  for (i = 0; i < plane_resources->count_planes; i++) {
+    drmModePlane *plane = drmModeGetPlane (fd, plane_resources->planes[i]);
+    if (plane->possible_crtcs & (1 << c->pipe)) {
+      *out_plane = plane;
+      break;
+    }
+  }
+
+  if (*out_plane == NULL)
+    goto error_no_plane;
+
+  c->fb_bo = omap_bo_new (dev, best_area * 2, OMAP_BO_WC);
+  if (c->fb_bo) {
+    uint32_t fourcc = DRM_FORMAT_RGB565;
+    uint32_t handles[4] = { omap_bo_handle (c->fb_bo) };
+    uint32_t pitches[4] = { c->mode->hdisplay * 2 };
+    uint32_t offsets[4] = { 0 };
+    ret = drmModeAddFB2 (fd, c->mode->hdisplay, c->mode->vdisplay,
+        fourcc, handles, pitches, offsets, &c->fb_id, 0);
+    if (ret) {
+      /* TODO */
+    }
+  }
+
+  /* now set the desired mode: */
+  ret = drmModeSetCrtc (fd, c->crtc, c->fb_id, 0, 0, &c->id, 1, c->mode);
+  if (ret) {
+    /* TODO */
+  }
+
+  return TRUE;
+
+fail:
+  gst_drm_connector_cleanup (fd, c);
+
+  return FALSE;
+
+error_no_connector:
+  GST_DEBUG ("could not get connector %s", strerror (errno));
+  goto fail;
+
+error_no_mode:
+  GST_DEBUG ("could not find mode %dx%d (count_modes %d)",
+      width, height, c->connector->count_modes);
+  goto fail;
+
+error_no_encoder:
+  GST_DEBUG ("could not get encoder: %s", strerror (errno));
+  goto fail;
+
+error_no_crtc:
+  GST_DEBUG ("couldn't find a crtc");
+  goto fail;
+
+error_no_plane:
+  GST_DEBUG ("couldn't find a plane");
+  goto fail;
+}
+
+gboolean
+gst_drm_connector_find_mode_and_plane (int fd,
+    struct omap_device *dev, int width, int height,
+    drmModeRes * resources, drmModePlaneRes * plane_resources,
+    struct connector *c, drmModePlane ** out_plane)
+{
+  int i;
+  gboolean found = FALSE;
+
+  /* First, find the connector & mode */
+  if (c->id == 0) {
+    /* Any connector */
+    GST_DEBUG ("Any connector, %d available", resources->count_connectors);
+    for (i = 0; i < resources->count_connectors; i++) {
+      GST_DEBUG ("  %d", resources->connectors[i]);
+    }
+    for (i = 0; i < resources->count_connectors; i++) {
+      GST_DEBUG ("Trying connector %d: %d", i, resources->connectors[i]);
+      c->id = resources->connectors[i];
+      if (gst_drm_connector_find_mode_and_plane_helper (fd, dev, width, height,
+              resources, plane_resources, c, out_plane)) {
+        GST_DEBUG ("Found suitable connector");
+        found = TRUE;
+        break;
+      }
+      GST_DEBUG ("Connector not suitable");
+    }
+  } else {
+    /* A specific connector */
+    GST_DEBUG ("Connector %d", c->id);
+    found =
+        gst_drm_connector_find_mode_and_plane_helper (fd, dev, width, height,
+        resources, plane_resources, c, out_plane);
+  }
+
+  return found;
+}
+
+/* table nicked off libdrm's modetest.c */
+/* *INDENT-OFF* */
+static const struct {
+  int type_id;
+  const char *type_name;
+} connector_type_names[] = {
+  { DRM_MODE_CONNECTOR_Unknown, "unknown" },
+  { DRM_MODE_CONNECTOR_VGA, "VGA" },
+  { DRM_MODE_CONNECTOR_DVII, "DVI-I" },
+  { DRM_MODE_CONNECTOR_DVID, "DVI-D" },
+  { DRM_MODE_CONNECTOR_DVIA, "DVI-A" },
+  { DRM_MODE_CONNECTOR_Composite, "composite" },
+  { DRM_MODE_CONNECTOR_SVIDEO, "s-video" },
+  { DRM_MODE_CONNECTOR_LVDS, "LVDS" },
+  { DRM_MODE_CONNECTOR_Component, "component" },
+  { DRM_MODE_CONNECTOR_9PinDIN, "9-pin-DIN" },
+  { DRM_MODE_CONNECTOR_DisplayPort, "displayport" },
+  { DRM_MODE_CONNECTOR_HDMIA, "HDMI-A" },
+  { DRM_MODE_CONNECTOR_HDMIB, "HDMI-B" },
+  { DRM_MODE_CONNECTOR_TV, "TV" },
+  { DRM_MODE_CONNECTOR_eDP, "embedded-displayport" },
+};
+/* *INDENT-ON* */
+
+gboolean
+gst_drm_connector_find_mode_and_plane_by_name (int fd,
+    struct omap_device * dev, int width, int height,
+    drmModeRes * resources, drmModePlaneRes * plane_resources,
+    struct connector * c, const char *name, drmModePlane ** out_plane)
+{
+  int i, n;
+  char tmp[64];
+  const char *type_name;
+  int found[G_N_ELEMENTS (connector_type_names)] = { 0 };
+
+  /* Find connector from name */
+  for (i = 0; i < resources->count_connectors; i++) {
+    GST_DEBUG ("Trying connector %d: %d", i, resources->connectors[i]);
+    c->id = resources->connectors[i];
+    c->connector = drmModeGetConnector (fd, c->id);
+    if (!c->connector)
+      continue;
+
+    /* Find type name from this connector */
+    for (n = 0; n < G_N_ELEMENTS (connector_type_names); n++)
+      if (connector_type_names[n].type_id == c->connector->connector_type)
+        break;
+    if (n == G_N_ELEMENTS (connector_type_names))
+      continue;
+
+    type_name = connector_type_names[n].type_name;
+    GST_DEBUG ("Connector %d has type %s", i, type_name);
+    ++found[n];
+
+    drmModeFreeConnector (c->connector);
+    c->connector = NULL;
+
+    /* Try a few different matches, such as modetest and xrandr
+       output, and also a indexless one matching first found */
+    snprintf (tmp, sizeof (tmp), "%s-%u", type_name, found[n]);
+    if (!g_ascii_strcasecmp (tmp, name))
+      goto found;
+    snprintf (tmp, sizeof (tmp), "%s%u", type_name, found[n]);
+    if (!g_ascii_strcasecmp (tmp, name))
+      goto found;
+    if (!g_ascii_strcasecmp (name, type_name))
+      goto found;
+
+    continue;
+
+  found:
+    if (gst_drm_connector_find_mode_and_plane_helper (fd, dev, width, height,
+            resources, plane_resources, c, out_plane)) {
+      GST_DEBUG ("Found suitable connector");
+      return TRUE;
+    }
+    GST_DEBUG ("Connector not suitable");
+  }
+
+  return FALSE;
+}
diff --git a/sys/kms/gstdrmutils.h b/sys/kms/gstdrmutils.h
new file mode 100644
index 0000000..053a245
--- /dev/null
+++ b/sys/kms/gstdrmutils.h
@@ -0,0 +1,40 @@
+#ifndef __GST_DRMUTILS_H__
+#define __GST_DRMUTILS_H__
+
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <assert.h>
+#include <xf86drmMode.h>
+#include <omap_drm.h>
+#include <omap_drmif.h>
+#include <drm_fourcc.h>
+#include <gst/gst.h>
+
+struct connector {
+	uint32_t id;
+	char mode_str[64];
+	drmModeConnector *connector;
+	drmModeModeInfo *mode;
+	drmModeEncoder *encoder;
+	uint32_t fb_id;
+	struct omap_bo *fb_bo;
+	int crtc;
+	int pipe;
+};
+
+void gst_drm_connector_cleanup (int fd, struct connector * c);
+gboolean gst_drm_connector_find_mode_and_plane (int fd,
+    struct omap_device * dev, int width, int height,
+    drmModeRes * resources, drmModePlaneRes * plane_resources,
+    struct connector *c, drmModePlane ** out_plane);
+gboolean gst_drm_connector_find_mode_and_plane_by_name (int fd,
+    struct omap_device *dev, int width, int height,
+    drmModeRes * resources, drmModePlaneRes * plane_resources,
+    struct connector *c, const char *name,
+    drmModePlane ** out_plane);
+
+#endif /* __GST_DRMUTILS_H__ */
diff --git a/sys/kms/gstkmsbufferpriv.c b/sys/kms/gstkmsbufferpriv.c
new file mode 100644
index 0000000..ffa7e46
--- /dev/null
+++ b/sys/kms/gstkmsbufferpriv.c
@@ -0,0 +1,124 @@
+/*
+ * GStreamer
+ *
+ * Copyright (C) 2012 Texas Instruments
+ * Copyright (C) 2012 Collabora Ltd
+ *
+ * Authors:
+ *  Alessandro Decina <alessandro.decina@collabora.co.uk>
+ *  Rob Clark <rob.clark@linaro.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation
+ * version 2.1 of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdint.h>
+#include <gst/gst.h>
+#include <gst/dmabuf/dmabuf.h>
+
+#include <omap_drm.h>
+#include <omap_drmif.h>
+#include <xf86drmMode.h>
+
+#include "gstkmssink.h"
+#include "gstkmsbufferpriv.h"
+
+static int
+create_fb (GstKMSBufferPriv * priv, GstKMSSink * sink)
+{
+  /* TODO get format, etc from caps.. and query device for
+   * supported formats, and make this all more flexible to
+   * cope with various formats:
+   */
+  uint32_t fourcc = GST_MAKE_FOURCC ('N', 'V', '1', '2');
+
+  uint32_t handles[4] = {
+    omap_bo_handle (priv->bo), omap_bo_handle (priv->bo),
+  };
+  uint32_t pitches[4] = {
+    GST_ROUND_UP_4 (sink->input_width), GST_ROUND_UP_4 (sink->input_width),
+  };
+  uint32_t offsets[4] = {
+    0, pitches[0] * sink->input_height
+  };
+
+  return drmModeAddFB2 (priv->fd, sink->input_width, sink->input_height,
+      fourcc, handles, pitches, offsets, &priv->fb_id, 0);
+}
+
+/**
+ * gst_kms_buffer_priv:
+ * @sink: a #GstKMSSink
+ * @buf: a pointer to #GstBuffer
+ *
+ * Checks if the @buf has a GstMetaDmaBuf metadata set. If it doesn't we return a NULL
+ * indicating its not a dmabuf buffer. We maintain a hashtable with dmabuf fd as key and 
+ * the GstKMSBufferPriv structure as value
+ *
+ * Returns: the #GstKMSBufferPriv
+ *
+ * Since: 1.2.?
+ */
+GstKMSBufferPriv *
+gst_kms_buffer_priv (GstKMSSink * sink, GstBuffer * buf)
+{
+    GstMetaDmaBuf *dmabuf = gst_buffer_get_dma_buf_meta (buf);
+
+
+    struct omap_bo *bo;
+    int fd;
+    int fd_copy;
+    GstKMSBufferPriv * priv;
+
+    /* if it isn't a dmabuf buffer that we can import, then there
+     * is nothing we can do with it:
+     */
+   
+    if (!dmabuf) {
+      GST_DEBUG_OBJECT (sink, "not importing non dmabuf buffer");
+      return NULL;
+    }
+
+    fd_copy = gst_dma_buf_meta_get_fd (dmabuf);
+
+    /* lookup the hashtable with fd as key. If present return bo & buffer structure */
+    priv = g_hash_table_lookup (sink->kmsbufferpriv, (gpointer)fd_copy);
+    if(priv) {
+       return priv;
+     }
+
+    priv = g_malloc0 (sizeof (GstKMSBufferPriv));
+    bo = omap_bo_from_dmabuf (sink->dev, fd_copy);
+    fd = sink->fd;
+
+      priv->bo = bo;
+      priv->fd = fd;
+
+    if (create_fb (priv, sink)) {
+      GST_WARNING_OBJECT (sink, "could not create framebuffer: %s",
+          strerror (errno));
+      g_free(priv);
+      return NULL;
+    }
+
+    /* if fd not present, write to hash table fd and the corresponding priv. */
+    g_hash_table_insert(sink->kmsbufferpriv, (gpointer)fd_copy, priv); 
+   
+  
+  return priv;
+}
diff --git a/sys/kms/gstkmsbufferpriv.h b/sys/kms/gstkmsbufferpriv.h
new file mode 100644
index 0000000..a1070da
--- /dev/null
+++ b/sys/kms/gstkmsbufferpriv.h
@@ -0,0 +1,64 @@
+/*
+ * GStreamer
+ *
+ * Copyright (C) 2012 Texas Instruments
+ * Copyright (C) 2012 Collabora Ltd
+ *
+ * Authors:
+ *  Alessandro Decina <alessandro.decina@collabora.co.uk>
+ *  Rob Clark <rob.clark@linaro.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation
+ * version 2.1 of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef __GSTKMSBUFFERPRIV_H__
+#define __GSTKMSBUFFERPRIV_H__
+
+#include <stdint.h>
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+
+/*
+ * per-buffer private data so kmssink can attach a drm_framebuffer
+ * handle (fb_id) to a buffer, which gets deleted when the buffer
+ * is finalized
+ */
+
+#define GST_TYPE_KMS_BUFFER_PRIV      \
+  (gst_kms_buffer_priv_get_type ())
+#define GST_KMS_BUFFER_PRIV(obj)      \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_KMS_BUFFER_PRIV, GstKMSBufferPriv))
+#define GST_IS_KMS_BUFFER_PRIV(obj)     \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_KMS_BUFFER_PRIV))
+
+
+typedef struct
+{
+  struct omap_bo *bo;
+  int fd;
+  uint32_t fb_id;
+}GstKMSBufferPriv;
+
+
+GType gst_kms_buffer_priv_get_type (void);
+
+/* Returns a GstKMSBufferPriv, if it has a dmabuf fd metadata */
+GstKMSBufferPriv * gst_kms_buffer_priv (GstKMSSink *sink, GstBuffer * buf);
+
+G_END_DECLS
+
+
+#endif /* __GSTKMSBUFFERPRIV_H__ */
diff --git a/sys/kms/gstkmssink.c b/sys/kms/gstkmssink.c
new file mode 100644
index 0000000..b9c9095
--- /dev/null
+++ b/sys/kms/gstkmssink.c
@@ -0,0 +1,682 @@
+/* GStreamer
+ * Copyright (C) 2012 Texas Instruments
+ * Copyright (C) 2012 Collabora Ltd
+ *
+ * Authors:
+ *  Alessandro Decina <alessandro.decina@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors:
+ *  Alessandro Decina <alessandro.decina@collabora.co.uk>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstkmssink.h"
+#include "gstkmsbufferpriv.h"
+
+#include <libdce.h>
+#include <omap_drm.h>
+#include <omap_drmif.h>
+#include <xf86drmMode.h>
+
+GST_DEBUG_CATEGORY (gst_debug_kms_sink);
+#define GST_CAT_DEFAULT gst_debug_kms_sink
+
+G_DEFINE_TYPE (GstKMSSink, gst_kms_sink, GST_TYPE_VIDEO_SINK);
+
+static void gst_kms_sink_reset (GstKMSSink * sink);
+
+static GstStaticPadTemplate gst_kms_sink_template_factory =
+GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (GST_VIDEO_CAPS_MAKE("NV12"))
+    );
+
+enum
+{
+  PROP_0,
+  PROP_PIXEL_ASPECT_RATIO,
+  PROP_FORCE_ASPECT_RATIO,
+  PROP_SCALE,
+  PROP_CONNECTOR,
+  PROP_CONNECTOR_NAME,
+};
+
+static inline void
+display_bufs_queue (GstKMSSink * sink, GstBuffer * buf)
+{
+  int i;
+  for (i = 0; i < (NUM_DISPLAY_BUFS - 1); i++)
+    gst_buffer_replace (&sink->display_bufs[i], sink->display_bufs[i + 1]);
+  gst_buffer_replace (&sink->display_bufs[i], buf);
+}
+
+static inline void
+display_bufs_free (GstKMSSink * sink)
+{
+  int i;
+  for (i = 0; i < NUM_DISPLAY_BUFS; i++)
+    gst_buffer_replace (&sink->display_bufs[i], NULL);
+}
+
+static gboolean
+gst_kms_sink_calculate_aspect_ratio (GstKMSSink * sink, gint width,
+    gint height, gint video_par_n, gint video_par_d)
+{
+  guint calculated_par_n;
+  guint calculated_par_d;
+
+  if (!gst_video_calculate_display_ratio (&calculated_par_n, &calculated_par_d,
+          width, height, video_par_n, video_par_d, 1, 1)) {
+    GST_ELEMENT_ERROR (sink, CORE, NEGOTIATION, (NULL),
+        ("Error calculating the output display ratio of the video."));
+    return FALSE;
+  }
+  GST_DEBUG_OBJECT (sink,
+      "video width/height: %dx%d, calculated display ratio: %d/%d",
+      width, height, calculated_par_n, calculated_par_d);
+
+  /* now find a width x height that respects this display ratio.
+   * prefer those that have one of w/h the same as the incoming video
+   * using wd / hd = calculated_pad_n / calculated_par_d */
+
+  /* start with same height, because of interlaced video */
+  /* check hd / calculated_par_d is an integer scale factor, and scale wd with the PAR */
+  if (height % calculated_par_d == 0) {
+    GST_DEBUG_OBJECT (sink, "keeping video height");
+    GST_VIDEO_SINK_WIDTH (sink) = (guint)
+        gst_util_uint64_scale_int (height, calculated_par_n, calculated_par_d);
+    GST_VIDEO_SINK_HEIGHT (sink) = height;
+  } else if (width % calculated_par_n == 0) {
+    GST_DEBUG_OBJECT (sink, "keeping video width");
+    GST_VIDEO_SINK_WIDTH (sink) = width;
+    GST_VIDEO_SINK_HEIGHT (sink) = (guint)
+        gst_util_uint64_scale_int (width, calculated_par_d, calculated_par_n);
+  } else {
+    GST_DEBUG_OBJECT (sink, "approximating while keeping video height");
+    GST_VIDEO_SINK_WIDTH (sink) = (guint)
+        gst_util_uint64_scale_int (height, calculated_par_n, calculated_par_d);
+    GST_VIDEO_SINK_HEIGHT (sink) = height;
+  }
+  GST_DEBUG_OBJECT (sink, "scaling to %dx%d",
+      GST_VIDEO_SINK_WIDTH (sink), GST_VIDEO_SINK_HEIGHT (sink));
+
+  return TRUE;
+}
+
+static gboolean
+gst_kms_sink_setcaps (GstBaseSink * bsink, GstCaps * caps)
+{
+  GstKMSSink *sink;
+  gboolean ret = TRUE;
+  gint width, height;
+  gint fps_n, fps_d;
+  gint par_n, par_d;
+  GstVideoFormat format;
+  GstVideoInfo info;
+
+  sink = GST_KMS_SINK (bsink);
+
+  ret = gst_video_info_from_caps (&info, caps);
+  format = GST_VIDEO_INFO_FORMAT(&info);
+  width = GST_VIDEO_INFO_WIDTH(&info);
+  height = GST_VIDEO_INFO_HEIGHT(&info);
+  fps_n = GST_VIDEO_INFO_FPS_N(&info);
+  fps_d = GST_VIDEO_INFO_FPS_D(&info);
+  par_n = GST_VIDEO_INFO_PAR_N(&info);
+  par_d = GST_VIDEO_INFO_PAR_D(&info);
+
+  if (!ret)
+    return FALSE;
+
+  if (width <= 0 || height <= 0) {
+    GST_ELEMENT_ERROR (sink, CORE, NEGOTIATION, (NULL),
+        ("Invalid image size."));
+    return FALSE;
+  }
+
+  sink->format = format;
+  sink->par_n = par_n;
+  sink->par_d = par_d;
+  sink->src_rect.x = sink->src_rect.y = 0;
+  sink->src_rect.w = width;
+  sink->src_rect.h = height;
+  sink->input_width = width;
+  sink->input_height = height;
+
+  if (!sink->pool || !gst_drm_buffer_pool_check_caps (sink->pool, caps)) {
+    int size;
+
+    if (sink->pool) {
+      gst_drm_buffer_pool_destroy (sink->pool);
+      sink->pool = NULL;
+    }
+
+    size = GST_VIDEO_INFO_SIZE(&info);
+    sink->pool = gst_drm_buffer_pool_new (GST_ELEMENT (sink),
+        sink->fd, caps, size);
+  }
+
+  sink->conn.crtc = -1;
+  sink->plane = NULL;
+
+  return TRUE;
+}
+
+static void
+gst_kms_sink_get_times (GstBaseSink * bsink, GstBuffer * buf,
+    GstClockTime * start, GstClockTime * end)
+{
+  GstKMSSink *sink;
+
+  sink = GST_KMS_SINK (bsink);
+
+  if (GST_BUFFER_PTS_IS_VALID (buf)) {
+    *start = GST_BUFFER_PTS (buf);
+    if (GST_BUFFER_DURATION_IS_VALID (buf)) {
+      *end = *start + GST_BUFFER_DURATION (buf);
+    } else {
+      if (sink->fps_n > 0) {
+        *end = *start +
+            gst_util_uint64_scale_int (GST_SECOND, sink->fps_d, sink->fps_n);
+      }
+    }
+  }
+}
+
+static GstFlowReturn
+gst_kms_sink_show_frame (GstVideoSink * vsink, GstBuffer * inbuf)
+{
+  GstKMSSink *sink = GST_KMS_SINK (vsink);
+  GstBuffer *buf = NULL;
+  GstKMSBufferPriv *priv;
+  GstFlowReturn flow_ret = GST_FLOW_OK;
+  int ret;
+  gint width, height;
+  GstVideoRectangle *c = &sink->src_rect;
+
+ GstVideoCropMeta* crop = gst_buffer_get_video_crop_meta (inbuf);
+ if (crop){
+  c->y = crop->y;
+  c->x = crop->x;
+
+ if (crop->width >= 0) {
+     width = crop->width;
+ }
+ else {
+     width = GST_VIDEO_SINK_WIDTH (sink);
+  }
+ if (crop->height >= 0){
+        height = crop->height;
+ }
+ else {
+        height = GST_VIDEO_SINK_HEIGHT (sink);
+  }
+}
+
+
+ c->w = width;
+ c->h = height;
+
+
+if (!gst_kms_sink_calculate_aspect_ratio (sink, width, height,
+              sink->par_n, sink->par_d))
+  GST_DEBUG_OBJECT (sink, "calculate aspect ratio failed");
+
+
+  GST_INFO_OBJECT (sink, "enter");
+
+  if (sink->conn.crtc == -1) {
+    GstVideoRectangle dest = { 0 };
+
+    if (sink->conn_name) {
+      if (!gst_drm_connector_find_mode_and_plane_by_name (sink->fd,
+              sink->dev, sink->src_rect.w, sink->src_rect.h,
+              sink->resources, sink->plane_resources, &sink->conn,
+              sink->conn_name, &sink->plane))
+        goto connector_not_found;
+    } else {
+      sink->conn.id = sink->conn_id;
+      if (!gst_drm_connector_find_mode_and_plane (sink->fd,
+              sink->dev, sink->src_rect.w, sink->src_rect.h,
+              sink->resources, sink->plane_resources, &sink->conn,
+              &sink->plane))
+        goto connector_not_found;
+    }
+
+    dest.w = sink->conn.mode->hdisplay;
+    dest.h = sink->conn.mode->vdisplay;
+    gst_video_sink_center_rect (sink->src_rect, dest, &sink->dst_rect,
+        sink->scale);
+  }
+
+  priv = gst_kms_buffer_priv (sink, inbuf);
+  if (priv) {
+    buf = gst_buffer_ref (inbuf);
+  } else {
+    GST_LOG_OBJECT (sink, "not a KMS buffer, slow-path!");
+    buf = gst_drm_buffer_pool_get (sink->pool, FALSE);
+    if (buf) {
+      GST_BUFFER_PTS (buf) = GST_BUFFER_PTS (inbuf);
+      GST_BUFFER_DURATION (buf) = GST_BUFFER_DURATION (inbuf);
+      gst_buffer_copy_into (buf, inbuf, GST_BUFFER_COPY_DEEP, 0 ,-1);
+      priv = gst_kms_buffer_priv (sink, buf);
+    }
+    if (!priv)
+      goto add_fb2_failed;
+  }
+
+  ret = drmModeSetPlane (sink->fd, sink->plane->plane_id,
+      sink->conn.crtc, priv->fb_id, 0,
+      sink->dst_rect.x, sink->dst_rect.y, sink->dst_rect.w, sink->dst_rect.h,
+      sink->src_rect.x << 16, sink->src_rect.y << 16,
+      sink->src_rect.w << 16, sink->src_rect.h << 16);
+  if (ret)
+    goto set_plane_failed;
+
+  display_bufs_queue (sink, buf);
+
+out:
+  GST_INFO_OBJECT (sink, "exit");
+  if (buf)
+    gst_buffer_unref (buf);
+  return flow_ret;
+
+add_fb2_failed:
+  GST_ELEMENT_ERROR (sink, RESOURCE, FAILED,
+      (NULL), ("drmModeAddFB2 failed: %s (%d)", strerror (errno), errno));
+  flow_ret = GST_FLOW_ERROR;
+  goto out;
+
+set_plane_failed:
+  GST_ELEMENT_ERROR (sink, RESOURCE, FAILED,
+      (NULL), ("drmModeSetPlane failed: %s (%d)", strerror (errno), errno));
+  flow_ret = GST_FLOW_ERROR;
+  goto out;
+
+connector_not_found:
+  GST_ELEMENT_ERROR (sink, RESOURCE, NOT_FOUND,
+      (NULL), ("connector not found", strerror (errno), errno));
+  goto out;
+}
+
+
+static gboolean
+gst_kms_sink_event (GstBaseSink * bsink, GstEvent * event)
+{
+  GstKMSSink *sink = GST_KMS_SINK (bsink);
+
+  switch (GST_EVENT_TYPE (event)) {
+    default:
+      break;
+  }
+  if (GST_BASE_SINK_CLASS (gst_kms_sink_parent_class)->event)
+    return GST_BASE_SINK_CLASS (gst_kms_sink_parent_class)->event (bsink,
+        event);
+  else
+    return TRUE;
+}
+
+static void
+gst_kms_sink_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstKMSSink *sink;
+
+  g_return_if_fail (GST_IS_KMS_SINK (object));
+
+  sink = GST_KMS_SINK (object);
+
+  switch (prop_id) {
+    case PROP_FORCE_ASPECT_RATIO:
+      sink->keep_aspect = g_value_get_boolean (value);
+      break;
+    case PROP_SCALE:
+      sink->scale = g_value_get_boolean (value);
+      break;
+    case PROP_CONNECTOR:
+      sink->conn_id = g_value_get_uint (value);
+      break;
+    case PROP_CONNECTOR_NAME:
+      g_free (sink->conn_name);
+      sink->conn_name = g_strdup (g_value_get_string (value));
+      break;
+    case PROP_PIXEL_ASPECT_RATIO:
+    {
+      GValue *tmp;
+
+      tmp = g_new0 (GValue, 1);
+      g_value_init (tmp, GST_TYPE_FRACTION);
+
+      if (!g_value_transform (value, tmp)) {
+        GST_WARNING_OBJECT (sink, "Could not transform string to aspect ratio");
+      } else {
+        sink->par_n = gst_value_get_fraction_numerator (tmp);
+        sink->par_d = gst_value_get_fraction_denominator (tmp);
+        GST_DEBUG_OBJECT (sink, "set PAR to %d/%d", sink->par_n, sink->par_d);
+      }
+      g_free (tmp);
+    }
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_kms_sink_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstKMSSink *sink;
+
+  g_return_if_fail (GST_IS_KMS_SINK (object));
+
+  sink = GST_KMS_SINK (object);
+
+  switch (prop_id) {
+    case PROP_FORCE_ASPECT_RATIO:
+      g_value_set_boolean (value, sink->keep_aspect);
+      break;
+    case PROP_SCALE:
+      g_value_set_boolean (value, sink->scale);
+      break;
+    case PROP_CONNECTOR:
+      g_value_set_uint (value, sink->conn.id);
+      break;
+    case PROP_PIXEL_ASPECT_RATIO:
+    {
+      char *v = g_strdup_printf ("%d/%d", sink->par_n, sink->par_d);
+      g_value_take_string (value, v);
+      break;
+    }
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_kms_sink_reset (GstKMSSink * sink)
+{
+  GST_DEBUG_OBJECT (sink, "reset");
+
+  if (sink->fd != -1) {
+    gst_drm_connector_cleanup (sink->fd, &sink->conn);
+  }
+  memset (&sink->conn, 0, sizeof (struct connector));
+
+  if (sink->pool) {
+    gst_drm_buffer_pool_destroy (sink->pool);
+    sink->pool = NULL;
+  }
+
+  if (sink->plane) {
+    drmModeFreePlane (sink->plane);
+    sink->plane = NULL;
+  }
+
+  if (sink->plane_resources) {
+    drmModeFreePlaneResources (sink->plane_resources);
+    sink->plane_resources = NULL;
+  }
+
+  if (sink->resources) {
+    drmModeFreeResources (sink->resources);
+    sink->resources = NULL;
+  }
+
+  display_bufs_free (sink);
+
+  if (sink->dev) {
+    dce_deinit (sink->dev);
+    sink->dev = NULL;
+    sink->fd = -1;
+  }
+
+  sink->par_n = sink->par_d = 1;
+  sink->src_rect.x = 0;
+  sink->src_rect.y = 0;
+  sink->src_rect.w = 0;
+  sink->src_rect.h = 0;
+  sink->input_width = 0;
+  sink->input_height = 0;
+  sink->format = GST_VIDEO_FORMAT_UNKNOWN;
+
+  memset (&sink->src_rect, 0, sizeof (GstVideoRectangle));
+  memset (&sink->dst_rect, 0, sizeof (GstVideoRectangle));
+}
+
+static gboolean
+gst_kms_sink_start (GstBaseSink * bsink)
+{
+  GstKMSSink *sink;
+
+  sink = GST_KMS_SINK (bsink);
+
+  sink->dev = dce_init ();
+  if (sink->dev == NULL)
+    goto device_failed;
+  else
+    sink->fd = dce_get_fd ();
+
+  sink->resources = drmModeGetResources (sink->fd);
+  if (sink->resources == NULL)
+    goto resources_failed;
+
+  sink->plane_resources = drmModeGetPlaneResources (sink->fd);
+  if (sink->plane_resources == NULL)
+    goto plane_resources_failed;
+
+  return TRUE;
+
+fail:
+  gst_kms_sink_reset (sink);
+  return FALSE;
+
+device_failed:
+  GST_ELEMENT_ERROR (sink, RESOURCE, FAILED,
+      (NULL), ("omap_device_new failed"));
+  goto fail;
+
+resources_failed:
+  GST_ELEMENT_ERROR (sink, RESOURCE, FAILED,
+      (NULL), ("drmModeGetResources failed: %s (%d)", strerror (errno), errno));
+  goto fail;
+
+plane_resources_failed:
+  GST_ELEMENT_ERROR (sink, RESOURCE, FAILED,
+      (NULL), ("drmModeGetPlaneResources failed: %s (%d)",
+          strerror (errno), errno));
+  goto fail;
+}
+
+static gboolean
+gst_kms_sink_stop (GstBaseSink * bsink)
+{
+  GstKMSSink *sink;
+
+  sink = GST_KMS_SINK (bsink);
+  gst_kms_sink_reset (sink);
+
+  return TRUE;
+}
+
+static GstFlowReturn
+gst_kms_sink_buffer_alloc (GstBaseSink * bsink, guint64 offset, guint size,
+    GstCaps * caps, GstBuffer ** buf)
+{
+  GstKMSSink *sink;
+  GstFlowReturn ret = GST_FLOW_OK;
+
+  sink = GST_KMS_SINK (bsink);
+
+  GST_DEBUG_OBJECT (sink, "begin");
+
+  if (G_UNLIKELY (!caps)) {
+    GST_WARNING_OBJECT (sink, "have no caps, doing fallback allocation");
+    *buf = NULL;
+    ret = GST_FLOW_OK;
+    goto beach;
+  }
+
+  GST_LOG_OBJECT (sink,
+      "a buffer of %d bytes was requested with caps %" GST_PTR_FORMAT
+      " and offset %" G_GUINT64_FORMAT, size, caps, offset);
+
+  /* initialize the buffer pool if not initialized yet */
+  if (G_UNLIKELY (!sink->pool || gst_drm_buffer_pool_size (sink->pool) != size)) {
+    GstVideoFormat format;
+    gint width, height;
+    GstVideoInfo info;
+
+    if (sink->pool) {
+      GST_INFO_OBJECT (sink, "in buffer alloc, pool->size != size");
+      gst_drm_buffer_pool_destroy (sink->pool);
+      sink->pool = NULL;
+    }
+
+    gst_video_info_from_caps (&info, caps);
+    format = GST_VIDEO_INFO_FORMAT(&info);
+    width = GST_VIDEO_INFO_WIDTH(&info);
+    height = GST_VIDEO_INFO_HEIGHT(&info);
+    size = GST_VIDEO_INFO_SIZE(&info);
+    sink->pool = gst_drm_buffer_pool_new (GST_ELEMENT (sink),
+        sink->fd, caps, size);
+  }
+  *buf = GST_BUFFER_CAST (gst_drm_buffer_pool_get (sink->pool, FALSE));
+
+beach:
+  return ret;
+}
+
+static void
+gst_kms_sink_finalize (GObject * object)
+{
+  GstKMSSink *sink;
+
+  sink = GST_KMS_SINK (object);
+  gst_kms_sink_reset (sink);
+  g_free (sink->conn_name);
+  if (sink->kmsbufferpriv){
+    g_hash_table_destroy (sink->kmsbufferpriv);
+    sink->kmsbufferpriv = NULL;
+}
+
+  G_OBJECT_CLASS (gst_kms_sink_parent_class)->finalize (object);
+}
+
+static void
+kmsbufferpriv_free_func (GstKMSBufferPriv *priv)
+{
+  drmModeRmFB (priv->fd, priv->fb_id);
+  omap_bo_del (priv->bo);
+  g_free(priv);
+}
+
+
+static void
+gst_kms_sink_init (GstKMSSink * sink)
+{
+  sink->fd = -1;
+  gst_kms_sink_reset (sink);
+  sink->kmsbufferpriv = g_hash_table_new_full (g_direct_hash, g_direct_equal,
+      NULL, (GDestroyNotify) kmsbufferpriv_free_func);
+}
+
+static void
+gst_kms_sink_class_init (GstKMSSinkClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *gstelement_class;
+  GstBaseSinkClass *gstbasesink_class;
+  GstVideoSinkClass *videosink_class;
+
+  gobject_class = (GObjectClass *) klass;
+  gstelement_class = (GstElementClass *) klass;
+  gstbasesink_class = (GstBaseSinkClass *) klass;
+  videosink_class = (GstVideoSinkClass *) klass;
+
+  gobject_class->finalize = gst_kms_sink_finalize;
+  gobject_class->set_property = gst_kms_sink_set_property;
+  gobject_class->get_property = gst_kms_sink_get_property;
+
+  g_object_class_install_property (gobject_class, PROP_FORCE_ASPECT_RATIO,
+      g_param_spec_boolean ("force-aspect-ratio", "Force aspect ratio",
+          "When enabled, reverse caps negotiation (scaling) will respect "
+          "original aspect ratio", FALSE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_PIXEL_ASPECT_RATIO,
+      g_param_spec_string ("pixel-aspect-ratio", "Pixel Aspect Ratio",
+          "The pixel aspect ratio of the device", "1/1",
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_SCALE,
+      g_param_spec_boolean ("scale", "Scale",
+          "When true, scale to render fullscreen", FALSE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_CONNECTOR,
+      g_param_spec_uint ("connector", "Connector",
+          "DRM connector id (0 for automatic selection)", 0, G_MAXUINT32, 0,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT));
+  g_object_class_install_property (gobject_class, PROP_CONNECTOR_NAME,
+      g_param_spec_string ("connector-name", "Connector name",
+          "DRM connector name (alternative to the connector property, "
+          "use $type$index, $type-$index, or $type)", "",
+          G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS));
+
+  gst_element_class_set_details_simple (gstelement_class,
+      "Video sink", "Sink/Video",
+      "A video sink using the linux kernel mode setting API",
+      "Alessandro Decina <alessandro.d@gmail.com>");
+
+  gst_element_class_add_pad_template (gstelement_class,
+      gst_static_pad_template_get (&gst_kms_sink_template_factory));
+
+  gstbasesink_class->set_caps = GST_DEBUG_FUNCPTR (gst_kms_sink_setcaps);
+  gstbasesink_class->get_times = GST_DEBUG_FUNCPTR (gst_kms_sink_get_times);
+  gstbasesink_class->event = GST_DEBUG_FUNCPTR (gst_kms_sink_event);
+  gstbasesink_class->start = GST_DEBUG_FUNCPTR (gst_kms_sink_start);
+  gstbasesink_class->stop = GST_DEBUG_FUNCPTR (gst_kms_sink_stop);
+
+  /* disable preroll as it's called before GST_CROP_EVENT has been received, so
+   * we end up configuring the wrong mode... (based on padded caps)
+   */
+  gstbasesink_class->preroll = NULL;
+  videosink_class->show_frame = GST_DEBUG_FUNCPTR (gst_kms_sink_show_frame);
+}
+
+static gboolean
+plugin_init (GstPlugin * plugin)
+{
+  if (!gst_element_register (plugin, "kmssink",
+          GST_RANK_PRIMARY + 1, GST_TYPE_KMS_SINK))
+    return FALSE;
+
+  GST_DEBUG_CATEGORY_INIT (gst_debug_kms_sink, "kmssink", 0, "kmssink element");
+
+  return TRUE;
+}
+
+GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
+    GST_VERSION_MINOR,
+    kms,
+    "KMS video output element",
+    plugin_init, VERSION, GST_LICENSE, GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
diff --git a/sys/kms/gstkmssink.h b/sys/kms/gstkmssink.h
new file mode 100644
index 0000000..6c312bb
--- /dev/null
+++ b/sys/kms/gstkmssink.h
@@ -0,0 +1,91 @@
+/* GStreamer
+ *
+ * Copyright (C) 2012 Texas Instruments 
+ * Copyright (C) 2012 Collabora Ltd
+ *
+ * Authors:
+ *  Alessandro Decina <alessandro.decina@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_KMS_SINK_H__
+#define __GST_KMS_SINK_H__
+
+#include <gst/video/video.h>
+#include <gst/video/gstvideosink.h>
+#include <gst/drm/gstdrmbufferpool.h>
+
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <assert.h>
+
+#include "gstdrmutils.h"
+
+G_BEGIN_DECLS
+#define GST_TYPE_KMS_SINK \
+  (gst_kms_sink_get_type())
+#define GST_KMS_SINK(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_KMS_SINK, GstKMSSink))
+#define GST_KMS_SINK_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_KMS_SINK, GstKMSSinkClass))
+#define GST_IS_KMS_SINK(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_KMS_SINK))
+#define GST_IS_KMS_SINK_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_KMS_SINK))
+typedef struct _GstKMSSink GstKMSSink;
+typedef struct _GstKMSSinkClass GstKMSSinkClass;
+
+#define NUM_DISPLAY_BUFS 4
+
+struct _GstKMSSink
+{
+  GstVideoSink videosink;
+  gint input_width, input_height;
+  GstVideoFormat format;
+  gint par_n, par_d;
+  gint fps_n, fps_d;
+  gboolean keep_aspect;
+  GstVideoRectangle src_rect;
+  GstVideoRectangle dst_rect;
+  int fd;
+  struct omap_device *dev;
+  drmModeRes *resources;
+  drmModePlaneRes *plane_resources;
+  struct connector conn;
+  uint32_t conn_id;
+  char *conn_name;
+  drmModePlane *plane;
+  GstDRMBufferPool *pool;
+  GHashTable *kmsbufferpriv;
+  /* current displayed buffer and last displayed buffer: */
+  GstBuffer *display_bufs[NUM_DISPLAY_BUFS];
+  gboolean scale;
+};
+
+struct _GstKMSSinkClass
+{
+  GstVideoSinkClass parent_class;
+};
+
+GType gst_kms_sink_get_type (void);
+
+G_END_DECLS
+#endif /* __GST_KMS_SINK_H__ */
-- 
1.7.9.5

